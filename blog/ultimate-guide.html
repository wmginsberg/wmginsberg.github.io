<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Tech Interview Cheatsheet</title>
    <style type="text/css">
    table {
	    border-collapse: collapse;
	}

	table, th, td {
	    border: 1px solid black;
	    padding: 5px;
	}
	th {
		height: 30px;
		background-color: #eee;
	}
	.code_snippet {
		font-family: monospace;
	}
	.code_snippet:hover {
		background-color: lightblue;
	}
	.subh3_bold {
		font-weight: 700;
	}
    </style>
  </head>
  <body>
  
  <h1> Tech Interview Cheatsheet </h1>

  <h2> Shortest Path Algorithms </h2>
  <p class="subh2">Find a path from source --> end</p>

  <h3> Dijkstra's Algorithm </h3>
  <p class="subh3">
  	<span class="subh3_bold">Runtime:</span> O(|V|)<sup>2</sup>or O((|V|+|E|) log |V|) <br />
  	Depends on implementation: the former using an array/linked this, and the latter using a binary heap. 
  	<br />
  	<span class="subh3_bold">Notes:</span> Cannot process negative edge weights.
  </p>

  <div class="code_snippet">
	function dijkstra(G,s):<br />
    &emsp;dist(v in V) = infinity<br />
    &emsp;prev(v in V) = null<br />
    &emsp;dist(s) = 0<br />
    &emsp;PQ = PriorityQueue(V)<br />
    &emsp;tree = []<br />
    &emsp;while PQ is not empty:<br />
    &emsp;&emsp;u = PQ.removeMin()<br />
    &emsp;&emsp;&emsp;for all edges (u,v):<br />
    &emsp;&emsp;&emsp;&emsp;if dist(v) > dist(u) + cost(u,v):<br />
    &emsp;&emsp;&emsp;&emsp;&emsp;dist(v) = dist(u) + cost(u,v)<br />
    &emsp;&emsp;&emsp;&emsp;&emsp;prev(v) = u<br />
    &emsp;&emsp;&emsp;&emsp;&emsp;PQ.replaceKey(v, dist(v))<br />
    &emsp;for v in V:<br />
    &emsp;&emsp;if v.prev is not null:<br />
    &emsp;&emsp;&emsp;tree.append(connecting_edge(v,v.prev))<br />
    &emsp;return tree<br />
  </div>

  <h3>Bellman-Ford Algorithm</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(|V|*|E|) <br />
	<span class="subh3_bold">Notes:</span> Relaxes |E| edges, |V|-1 times. Can process negative edge weights.
  </p>
  <div class="code_snippet">
	function BellmanFord(V,E,src):<br />
	&emsp;for each vertex v in vertices:<br />
	&emsp;&emsp;v.dist = infinity<br />
	&emsp;&emsp;if v = src:<br />
	&emsp;&emsp;&emsp;v.dist = 0<br />
	&emsp;&emsp;&emsp;v.prev = null<br />
	&emsp;repeat |V|-1 times:<br />
	&emsp;&emsp;for each edge (u,v) in E:<br />
	&emsp;&emsp;&emsp;if u.dist + (u,v).weight < v.dist:<br />
	&emsp;&emsp;&emsp;&emsp;v.dist = u.dist + (u,v).weight<br />
	&emsp;&emsp;&emsp;&emsp;v.prev = u<br />
	&emsp;// checking for negative cycles<br />
	&emsp;for each edge (u,v) in E:<br />
	&emsp;&emsp;if u.dist + (u,v).weight < v.dist:<br />
	&emsp;&emsp;&emsp;throw new NegativeCycleException()<br />
	&emsp;// build tree<br />
	&emsp;for v in V:<br />
	&emsp;&emsp;if v.prev is not null:<br />
	&emsp;&emsp;&emsp;tree.append(connecting_edge(v, v.prev))<br />
  </div>

  <h3>Top Sort</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(|V|+|E|)
  </p>
  <div class="code_snippet">
	function TopSort(G):<br />
	&emsp;S = Stack()<br />
	&emsp;L = []<br />
	&emsp;for each vertex in G:<br />
	&emsp;&emsp;if vertex has no incident edges:<br />
	&emsp;&emsp;&emsp;S.push(vertex)<br />
	&emsp;while S is not empty:<br />
	&emsp;&emsp;v = S.pop()<br />
	&emsp;&emsp;L.append(v)<br />
	&emsp;&emsp;for each outgoing edge e from v:<br />
	&emsp;&emsp;&emsp;w = e.destination<br />
	&emsp;&emsp;&emsp;delete e<br />
	&emsp;&emsp;&emsp;if w has no incident edges:<br />
	&emsp;&emsp;&emsp;&emsp;S.push(w)<br />
	&emsp;return L<br />
  </div>  

<hr>

  <h2> Minimum Spanning Tree Algorithms </h2>
  <p class="subh2">Find the MSTree of a graph, or MSForest of multiple graphs</p>

  <h3>Prim-Jarnik Algorithm</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O((|V|+|E|) log|V|) <br />
	<span class="subh3_bold">Notes:</span> Best to prove correctness by induction. This is a greedy algorithm.
  </p>
  <div class="code_snippet">
	function prim(G):<br />
	&emsp;for all vertices v in G:<br />
	&emsp;&emsp;v.cost = infinity<br />
	&emsp;&emsp;v.prev = null<br />
	&emsp;source = a random v in V<br />
	&emsp;source.cost = 0<br />
	&emsp;MST = []<br />
	&emsp;PQ = PriorityQueue(V)<br />
	&emsp;while PQ is not empty:<br />
	&emsp;&emsp;v = PQ>removeMin()<br />
	&emsp;&emsp;if v.prev != null:<br />
	&emsp;&emsp;&emsp;MST.append((v,v.prev))<br />
	&emsp;&emsp;for all incident edges (v,u) of v:<br />
	&emsp;&emsp;&emsp;if u.cost > (v,u).weight<br />
	&emsp;&emsp;&emsp;&emsp;u.cost = (v,u).weight<br />
	&emsp;&emsp;&emsp;&emsp;u.prev = v <br />
	&emsp;&emsp;&emsp;PQ.replaceKey(u,u.cost)<br />
	&emsp;return MST<br />
  </div>

  <h3>Kruskal's Algorithm</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(|E|log|E|) <br />
	Thanks to union find/path compression this is the runtime. Without union find/recursive path compression, the runtime is O(|V|<sup>3</sup>) <br />
	<span class="subh3_bold">Notes:</span> Sorts all edges of the graph by weight in ascending order, and if its addition doesn’t create a cycle, add it to the MST. Detect cycles with “clouds”.
  </p>
  <div class="code_snippet">
	function kruskal(G):<br />
	&emsp;for vertices v in G:<br />
	&emsp;&emsp;v.parent = v<br />
	&emsp;&emsp;v.rank = 0<br />
	&emsp;MST = []<br />
	&emsp;for all edges(u,v) in G sorted by weight:<br />
	&emsp;&emsp;if u and v are not in same cloud:<br />
	&emsp;&emsp;if v.prev != null:<br />
	&emsp;&emsp;&emsp;MST.append((u,v))<br />
	&emsp;&emsp;&emsp;this.mergeClouds(u.parent, v.parent)<br />
	&emsp;&emsp;&emsp;this.pathCompress(v)<br />
	&emsp;return MST<br />
  </div>

  <p class="subh3">
  	<span class="subh3_bold">Helper Functions</span><br />
	<span class="subh3_bold">Runtime:</span> Amortized O(1)
  </p>

  <div class="code_snippet">
	function mergeClouds(p1, p2): // union<br />
	&emsp;if p1.rank > p2.rank:<br />
	&emsp;&emsp;p2.parent = p1<br />
	&emsp;else if p1.rank < p2.rank:<br />
	&emsp;&emsp;p1.parent = p2<br />
	&emsp;else:<br />
	&emsp;&emsp;p2.parent = p1<br />
	&emsp;&emsp;p1.rank++<br />
	<br />
	<br />
	function pathCompress(v): // find<br />
	&emsp;if v != v.parent:<br />
	&emsp;&emsp;v.parent = pathCompress(v.parent)<br />
	&emsp;return v.parent<br />
  </div>

<hr>

  <h2> Sorting Algorithms </h2>
  <p class="subh2">Sort a list</p>

  <table>
  <tr><th>Algorithm</th><th>Time</th><th>Notes</th></tr>
  <tr><td>Selection sort</td><td>O(n<sup>2</sup>)</td><td>in place<br>slow (good for small inputs)</td></tr>
  <tr><td>Insertion sort</td><td>O(n<sup>2</sup>)</td><td>in place<br>slow (good for small inputs)</td></tr>
  <tr><td>Merge sort</td><td>O(n log n)</td><td>fast (good for large inputs)</td></tr>
  <tr><td>Quick sort</td><td>O(n log n)<br>expected</td><td>randomized<br>fastest (good for large inputs)</td></tr>
  <tr><td>Radix sort</td><td>O(nd)</td><td>d is number of digits in largest number<br>basically linear when d is small</td></tr>
  </table>
  <p> Mnemonic: SQuIRM (n<sup>2</sup>, n log n, n<sup>2</sup>,nd, n log n)

  <h3>Merge Sort</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">
  function merge_sort(A):<br />
  &emsp;n = A.length()<br />
  &emsp;if n <= 1:<br />
  &emsp;&emsp;return A<br />
  &emsp;mid = n/2<br />
  &emsp;left = mergeSort(A[0 … mid-1])<br />
  &emsp;right = mergeSort(A[mid .. n-1])<br />
  &emsp;return merge(left,right)<br />
<br />
  function merge(A, B):<br />
  &emsp;result = []<br />
  &emsp;aIndex = bIndex = 0<br />
  &emsp;while aIndex < A.length() and bIndex < B.length():<br />
  &emsp;&emsp;if A[aIndex] < B[bIndex]:<br />
  &emsp;&emsp;&emsp;result.append(A[aIndex])<br />
  &emsp;&emsp;&emsp;aIndex++<br />
  &emsp;if aIndex < A.length():<br />
  &emsp;&emsp;result = result + A[aIndex...end]<br />
  &emsp;if bIndex < B.length():<br />
  &emsp;&emsp;result = result + B[bIndex...end]<br />
  &emsp;return result<br />
	
  </div>

  <h3>Selection Sort</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n<sup>2</sup>) <br />
	<span class="subh3_bold">Notes:</span> usually written iteratively and in-place. finds the min and moves it to the first index (then second, third, etc.)
  </p>
  <div class="code_snippet">
  function selection_sort(A):<br />
  &emsp;// Input: Unsorted List<br />
  &emsp;// Output: Sorted List<br />
  &emsp;n = A.length<br />
  &emsp;for i = 0 to n-2:<br />
  &emsp;&emsp;min = argmin(A[i...n-1])<br />
  &emsp;&emsp;swap A[i] with A[min]<br />
  </div>

  <h3>Insertion Sort</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n<sup>2</sup>) <br />
	<span class="subh3_bold">Notes:</span> very fast if already partially sorted
  </p>
  <div class="code_snippet">
	function insertion_sort(A):<br />
	&emsp;n = A.length()<br />
	&emsp;for i = 1 to n-1:<br />
	&emsp;&emsp;for j = i down to 1:<br />
	&emsp;&emsp;&emsp;if A[j] < A[j-1]:<br />
	&emsp;&emsp;&emsp;&emsp;swap A[j] and A[j-1]<br />
	&emsp;&emsp;&emsp;else:<br />
	&emsp;&emsp;&emsp;&emsp;break<br />
  </div>

  <h3>Reverse</h3>
  <p class="subh3">
	<span class="subh3_bold">Notes:</span> in-place
  </p>
  <div class="code_snippet">
	function reverse(A):<br />
	&emsp;n = A.length<br />
	&emsp;for i = 0 to n/2:<br />
	&emsp;&emsp;temp = A[i]<br />
	&emsp;&emsp;A[i] = A[n−1−i]<br />
	&emsp;&emsp;A[n−1−i] = temp<br />
	
  </div>

  <h3>Quick Sort</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> worst case O(n<sup>2</sup>) , expected O(n log n) <br />
	<span class="subh3_bold">Notes:</span> divide and conquer around a random pivot point. partition the input list into L, E, and G for numbers less than equal to or greater than the pivot point. recursively solve until in order.
  </p>
  <div class="code_snippet">
	function quick_sort(A):<br />
	// Input: Unsorted List<br />
	// Output: Sorted List<br />
	&emsp;n = A.length<br />
	&emsp;if n <= 1<br />
	&emsp;&emsp;return A<br />
	&emsp;pivot = random element from A<br />
	&emsp;L, E, G = [ ]<br />
	&emsp;for each x in A:<br />
	&emsp;&emsp;if x < pivot:<br />
	&emsp;&emsp;&emsp;L.append(x)<br />
	&emsp;&emsp;else if x > pivot:<br />
	&emsp;&emsp;&emsp;G.append(x)<br />
	&emsp;&emsp;else:<br />
	&emsp;&emsp;&emsp;E.append(x)<br />
	&emsp;return quick_sort(L) + E + quick_sort(G)<br />	
  </div>

  <h3>Radix Sort</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">
	function radix_sort(A):<br />
	// Input: unsorted list<br />
	// Output: sorted list<br />
	&emsp;buckets = array of 10 lists<br />
	&emsp;for place = least to most significant<br />
	&emsp;&emsp;for number in A<br />
	&emsp;&emsp;&emsp;d = digit in number at place<br />
	&emsp;&emsp;&emsp;bucket[d].append(number)<br />
	&emsp;&emsp;A = concatenate all buckets in order<br />
	&emsp;&emsp;empty all buckets<br />
	&emsp;return A<br />
  </div>

<hr>

  <h2> Selection &amp; Search Algorithms </h2>
  <p class="subh2">Algorithms to find things</p>

  <h3>Selection</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> <br />
	expected: O(n) <br />
	worst case: O(n<sup>2</sup>)
  </p>
  <div class="code_snippet">
	function select(list, k):<br />
	\\ base case omitted<br />
	&emsp;pivot = list[rand(0, list.size)]<br />
	&emsp;L = E = R = []<br />
	&emsp;for x in list:<br />
	&emsp;&emsp;if x < pivot: L.append(x)<br />
	&emsp;&emsp;if x = pivot: E.append(x)<br />
	&emsp;&emsp;if x > pivot: R.append(x)<br />
	&emsp;if k <= L.size:<br />
	&emsp;&emsp;return select(L,k)<br />
	&emsp;else if k > L.size and k <= (L.size + E.size):<br />
	&emsp;&emsp;return pivot<br />
	&emsp;else:<br />
	&emsp;&emsp;return select(R,k)<br />
  </div>

  <h3>Median of Medians</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n) <br />
  </p>
  <div class="code_snippet">
	function momSelect(list, k):<br />
	//base cases omitted<br />
	&emsp;miniLists = divide list into n/5 lists of 5<br />
	&emsp;medians = []<br />
	&emsp;for miniList in miniLists:<br />
	&emsp;&emsp;sort(miniList) // O(1) because list is always of length 5<br />
	&emsp;&emsp;medians.append(miniList[2])<br />
	&emsp;pivot = momSelect(medians, medians.size()/2)<br />
	<br />
	&emsp;L = E = R = []<br />
	&emsp;for x in list:<br />
	&emsp;&emsp;if x < pivot: L.append(x)<br />
	&emsp;&emsp;if x = pivot: E.append(x)<br />
	&emsp;&emsp;if x > pivot: R.append(x)<br />
	&emsp;if k <= L.size:<br />
	&emsp;&emsp;return select(L,k)<br />
	&emsp;else if k > L.size and k <= (L.size + E.size):<br />
	&emsp;&emsp;return pivot<br />
	&emsp;else:<br />
	&emsp;return select(R,k)<br />
  </div>

  <h3>Binary Search</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(log n) <br />
	<span class="subh3_bold">Notes:</span> <br />
	Input: A – a sorted array, x – the item to find <br />
	Output: true if x is in the array <br />
  </p>
  <div class="code_snippet">
	function binarySearch(A, x):<br />
	&emsp;lo = 0<br />
	&emsp;hi = A.size - 1<br />
	&emsp;while lo < hi:<br />
	&emsp;&emsp;mid = (lo + hi) / 2<br />
	&emsp;&emsp;if A[mid] == x:<br />
	&emsp;&emsp;&emsp;return true<br />
	&emsp;&emsp;if A[mid] < x:<br />
	&emsp;&emsp;&emsp;lo = mid + 1<br />
	&emsp;&emsp;if A[mid] > x:<br />
	&emsp;&emsp;&emsp;hi = mid – 1<br />
	&emsp;return A[lo] == x<br />
  </div>

  <h3>Angular Graham Scan</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
  </p>

<hr>

  <h2> Tree Traversals </h2>
  <p class="subh2">Search through a tree</p>

  <h3>Breadth-First Traversal</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">
	function bft(root):<br />
	// Input: root node of tree<br />
	// Output: None<br />
	&emsp;Q = new Queue()<br />
	&emsp;enqueue root<br />
	&emsp;while Q is not empty:<br />
	&emsp;&emsp;node = Q.dequeue()<br />
	&emsp;&emsp;visit(node)<br />
	&emsp;&emsp;enqueue node’s left &amp; right children<br />
  </div>

  <h3>Depth-First Traversal</h3>
  <div class="code_snippet">
	function dft(root):<br />
	// Input: root node of tree<br />
	// Output: None<br />
	&emsp;S = new Stack()<br />
	&emsp;push root onto S<br />
	&emsp;while S is not empty:<br />
	&emsp;&emsp;node = S.pop()<br />
	&emsp;&emsp;visit(node)<br />
	&emsp;&emsp;push node’s left &amp; right children<br />
  </div>

  <h3>Recursive Breadth-First Traversal</h3>
  <div class="code_snippet">
	function preorder(node):<br />
	// Input: root node of tree<br />
	// Output: None<br />
	&emsp;visit(node)<br />
	&emsp;if node has left child<br />
	&emsp;&emsp;preorder(node.left)<br />
	&emsp;if node has right child<br />
	&emsp;&emsp;preorder(node.right)<br />
	<br />
	function inorder(node):<br />
	// Input: root node of tree<br />
	// Output: None<br />
	&emsp;if node has left child<br />
	&emsp;&emsp;preorder(node.left)<br />
	&emsp;visit(node)<br />
	&emsp;if node has right child<br />
	&emsp;&emsp;preorder(node.right)<br />
	<br />
	function postorder(node):<br />
	// Input: root node of tree<br />
	// Output: None<br />
	&emsp;if node has left child<br />
	&emsp;&emsp;postorder(node.left)<br />
	&emsp;if node has right child<br />
	&emsp;&emsp;postorder(node.right)<br />
	&emsp;visit(node)<br />
  </div>

<hr>

  <h2> Graphs v Trees </h2>
  <p> A graph G is a tree if and only if it satisfies any of the following 5 conditions: <br />
  <ul>
  	<li>G has V-1 edges and no cycles </li>
	<li>G has V-1 edges and is connected</li>
	<li>G is connected, but removing any edge disconnects it</li>
	<li>G is acyclic, but adding any edges creates a cycle</li>
	<li>Exactly one simple path connects each pair of vertices in G</li>
  </ul>

<hr>

  <h2> Abstract Data Types (ADTs) </h2>
  <table>
  	<tr><th>ADT</th><th>Structure</th><th>Main Methods</th><th>Properties</th></tr> 
  	<tr>
  		<td> PQ </td>
  		<td> Heap </td>
  		<td> insert(key,element)  O(log n) <br />
  			 removeMin()          O(log n) <br />
  			 <br />
  			 upheap()             O(log n) <br />
  			 downheap()           O(log n) <br />
  		</td>
  		<td>
  			- Binary: each node has <= 2 children<br />
  			- Key/priority at each node<br />
  			- Left-complete<br />
  			- Preserves heap order: min or max<br />
  			&emsp;- min: n.key >= n.parent.key<br />
  			&emsp;- max: n.key <= n.parent.key<br />
  		</td>
  	</tr>
  	<tr>
  		<td> Treap </td>
  		<td> BST + Heap </td>
  		<td> insert(key,element)  O(log n) <br />
  			 removeMin()          O(log n) <br />
  			 <br />
  			 upheap()             O(log n) <br />
  			 downheap()           O(log n) <br />
  		</td>
  		<td>
  			- A non-empty tree <em>T</em> with a key and a priority at each node<br />
  			- <em>T</em> has only one node, or<br />
  			- <em>T</em> has a root <em>R</em> whose left and right subtrees are both treaps <br />
  			- Node's priority preserves heap order<br />
  			- Node's key preserves BST ordering<br />
  		</td>
  	</tr>
  	<tr>
  		<td> Tree </td>
  		<td>  </td>
  		<td><u>tree methods:</u><br />
  			size() <br />
  			isEmpty() <br />
  			root() <br />
  			<br />
  			<u>node methods:</u><br />
  			parent()<br />
  			children()<br />
  			isInternal()<br />
  			isExternal()<br />
  			isRoot()<br />
  			<br />
  			<u>binary tree node methods:</u><br />
  			hasLeft()<br />
  			hasRight()<br />
  			left()<br />
  			right()<br />
  		</td>
  		<td>
  			# nodes = n <br />
  			# edges = n - 1<br />
  			height = h <br />
  			<br />
  			<u>perfect binary tree:</u> <br />
  			height = h = log(n+1)-1 <sub>(base 2)</sub> <br />
  			# nodes = n = 2<sup>(h+1)</sup>-1<br /> = 2L-1 <br />
  			# leaves = L = 2<sup>h</sup><br />
  		</td>
  	</tr>
  	<tr><td> Trie </td> <td> Prefix Tree </td><td> insert() <br /> find() </td><td> each node has a dictionary of children </td></tr>
  </table>


  <h2> Algorithms </h2>
  <table>
  	<tr><th>Problem</th><th>Algorithm</th><th>Runtime</th><th>Data Structure</th></tr> 
  	<tr> <td>Sorting</td> <td>Insertion sort</td> <td>n<sup>2</sup></td> <td></td> </tr>
  	<tr> <td></td> <td>Selection sort</td> <td>worst case: n<sup>2</sup><br>expected: n</td> <td></td> </tr>
  	<tr> <td></td> <td>Merge sort</td> <td>n log n</td> <td></td> </tr>
  	<tr> <td></td> <td>Quick sort</td> <td>n log n</td> <td></td> </tr>
  	<tr> <td></td> <td>Radix sort</td> <td>dn</td> <td></td> </tr>
  	<tr> <td>Tree Traversals</td> <td>Breadth first</td> <td></td> <td>Queue</td> </tr>
  	<tr> <td></td> <td>Depth first</td> <td></td> <td>Stack</td> </tr>
  	<tr> <td></td> <td>Pre-order</td> <td></td> <td></td> </tr>
  	<tr> <td></td> <td>In-order</td> <td></td> <td></td> </tr>
  	<tr> <td></td> <td>Post-order</td> <td></td> <td></td> </tr>
  	<tr> <td></td> <td>Euler tour</td> <td>Left side: pre-order<br>Bottom: in-order<br>Right side: post-order</td> <td></td> </tr>
  	<tr> <td>Graph stuff</td> <td>BFT</td> <td>V+E</td> <td>Queue</td> </tr>
  	<tr> <td></td> <td>DFT</td> <td>V+E</td> <td>Stack</td> </tr>
  	<tr> <td></td> <td>Top Sort</td> <td>V+E</td> <td>Stack, Queue, etc.</td> </tr>
  	<tr> <td>Shortest Paths</td> <td>Dijkstra</td> <td>|V|<sup>2</sup><br><br>(|V|+|E|)* log|V|</td> <td>Array/Linked list <br><br>PQ/Binary Heap, etc.</td> </tr>
  	<tr> <td></td> <td>A*</td> <td>(V+E)log(V)</td> <td>PQ/Binary Heap, etc.</td> </tr>
  	<tr> <td></td> <td>Bellman-Ford</td> <td>VE</td> <td></td> </tr>
  	<tr> <td>MSTs</td> <td>Prim-Jarnik</td> <td>(V+E)logV</td> <td>PQ</td> </tr>
  	<tr> <td></td> <td>Kruskals<br>(plus union find)</td> <td>ElogE</td> <td><PQ/td> </tr>
  </table>


  </body>
</html>