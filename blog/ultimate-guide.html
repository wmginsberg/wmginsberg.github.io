<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Tech Interview Cheatsheet</title>
  </head>
  <body>
  
  <h1> Tech Interview Cheatsheet </h1>

  <h2> Shortest Path Algorithms </h2>
  <p class="subh2">Find a path from source --> end</p>

  <h3> Dijkstra's Algorithm </h3>
  <p class="subh3">
  	<span class="subh3_bold">Runtime:</span> O(|V|)<sup>2</sup>or O((|V|+|E|) log |V|) <br />
  	Depends on implementation: the former using an array/linked this, and the latter using a binary heap. 
  	<br />
  	<span class="subh3_bold">Notes:</span> Cannot process negative edge weights.
  </p>

  <div class="code_snippet">
	function dijkstra(G,s):<br />
    &emsp;dist(v in V) = infinity<br />
    &emsp;prev(v in V) = null<br />
    &emsp;dist(s) = 0<br />
    &emsp;PQ = PriorityQueue(V)<br />
    &emsp;tree = []<br />
    &emsp;while PQ is not empty:<br />
    &emsp;&emsp;u = PQ.removeMin()<br />
    &emsp;&emsp;&emsp;for all edges (u,v):<br />
    &emsp;&emsp;&emsp;&emsp;if dist(v) > dist(u) + cost(u,v):<br />
    &emsp;&emsp;&emsp;&emsp;&emsp;dist(v) = dist(u) + cost(u,v)<br />
    &emsp;&emsp;&emsp;&emsp;&emsp;prev(v) = u<br />
    &emsp;&emsp;&emsp;&emsp;&emsp;PQ.replaceKey(v, dist(v))<br />
    &emsp;for v in V:<br />
    &emsp;&emsp;if v.prev is not null:<br />
    &emsp;&emsp;&emsp;tree.append(connecting_edge(v,v.prev))<br />
    &emsp;return tree<br />
  </div>

  <h3>Bellman-Ford Algorithm</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(|V|*|E|) <br />
	<span class="subh3_bold">Notes:</span> Relaxes |E| edges, |V|-1 times. Can process negative edge weights.
  </p>
  <div class="code_snippet">
	function BellmanFord(V,E,src):<br />
	&emsp;for each vertex v in vertices:<br />
	&emsp;&emsp;v.dist = infinity<br />
	&emsp;&emsp;if v = src:<br />
	&emsp;&emsp;&emsp;v.dist = 0<br />
	&emsp;&emsp;&emsp;v.prev = null<br />
	&emsp;repeat |V|-1 times:<br />
	&emsp;&emsp;for each edge (u,v) in E:<br />
	&emsp;&emsp;&emsp;if u.dist + (u,v).weight < v.dist:<br />
	&emsp;&emsp;&emsp;&emsp;v.dist = u.dist + (u,v).weight<br />
	&emsp;&emsp;&emsp;&emsp;v.prev = u<br />
	&emsp;// checking for negative cycles<br />
	&emsp;for each edge (u,v) in E:<br />
	&emsp;&emsp;if u.dist + (u,v).weight < v.dist:<br />
	&emsp;&emsp;&emsp;throw new NegativeCycleException()<br />
	&emsp;// build tree<br />
	&emsp;for v in V:<br />
	&emsp;&emsp;if v.prev is not null:<br />
	&emsp;&emsp;&emsp;tree.append(connecting_edge(v, v.prev))<br />
  </div>

  <h3>Top Sort</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(|V|+|E|)
  </p>
  <div class="code_snippet">
	function TopSort(G):<br />
	&emsp;S = Stack()<br />
	&emsp;L = []<br />
	&emsp;for each vertex in G:<br />
	&emsp;&emsp;if vertex has no incident edges:<br />
	&emsp;&emsp;&emsp;S.push(vertex)<br />
	&emsp;while S is not empty:<br />
	&emsp;&emsp;v = S.pop()<br />
	&emsp;&emsp;L.append(v)<br />
	&emsp;&emsp;for each outgoing edge e from v:<br />
	&emsp;&emsp;&emsp;w = e.destination<br />
	&emsp;&emsp;&emsp;delete e<br />
	&emsp;&emsp;&emsp;if w has no incident edges:<br />
	&emsp;&emsp;&emsp;&emsp;S.push(w)<br />
	&emsp;return L<br />
  </div>  

<hr>

  <h2> Minimum Spanning Tree Algorithms </h2>
  <p class="subh2">Find the MSTree of a graph, or MSForest of multiple graphs</p>

  <h3>Prim-Jarnik Algorithm</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O((|V|+|E|) log|V|) <br />
	<span class="subh3_bold">Notes:</span> Best to prove correctness by induction. This is a greedy algorithm.
  </p>
  <div class="code_snippet">
	function prim(G):<br />
	&emsp;for all vertices v in G:<br />
	&emsp;&emsp;v.cost = infinity<br />
	&emsp;&emsp;v.prev = null<br />
	&emsp;source = a random v in V<br />
	&emsp;source.cost = 0<br />
	&emsp;MST = []<br />
	&emsp;PQ = PriorityQueue(V)<br />
	&emsp;while PQ is not empty:<br />
	&emsp;&emsp;v = PQ>removeMin()<br />
	&emsp;&emsp;if v.prev != null:<br />
	&emsp;&emsp;&emsp;MST.append((v,v.prev))<br />
	&emsp;&emsp;for all incident edges (v,u) of v:<br />
	&emsp;&emsp;&emsp;if u.cost > (v,u).weight<br />
	&emsp;&emsp;&emsp;&emsp;u.cost = (v,u).weight<br />
	&emsp;&emsp;&emsp;&emsp;u.prev = v <br />
	&emsp;&emsp;&emsp;PQ.replaceKey(u,u.cost)<br />
	&emsp;return MST<br />
  </div>

  <h3>Kruskal's Algorithm</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(|E|log|E|) <br />
	Thanks to union find/path compression this is the runtime. Without union find/recursive path compression, the runtime is O(|V|<sup>3</sup>) <br />
	<span class="subh3_bold">Notes:</span> Sorts all edges of the graph by weight in ascending order, and if its addition doesn’t create a cycle, add it to the MST. Detect cycles with “clouds”.
  </p>
  <div class="code_snippet">
	function kruskal(G):<br />
	&emsp;for vertices v in G:<br />
	&emsp;&emsp;v.parent = v<br />
	&emsp;&emsp;v.rank = 0<br />
	&emsp;MST = []<br />
	&emsp;for all edges(u,v) in G sorted by weight:<br />
	&emsp;&emsp;if u and v are not in same cloud:<br />
	&emsp;&emsp;if v.prev != null:<br />
	&emsp;&emsp;&emsp;MST.append((u,v))<br />
	&emsp;&emsp;&emsp;this.mergeClouds(u.parent, v.parent)<br />
	&emsp;&emsp;&emsp;this.pathCompress(v)<br />
	&emsp;return MST<br />
  </div>

  <p class="subh3">
  	<span class="subh3_bold">Helper Functions</span><br />
	<span class="subh3_bold">Runtime:</span> Amortized O(1)
  </p>

  <div class="code_snippet">
	function mergeClouds(p1, p2): // union<br />
	&emsp;if p1.rank > p2.rank:<br />
	&emsp;&emsp;p2.parent = p1<br />
	&emsp;else if p1.rank < p2.rank:<br />
	&emsp;&emsp;p1.parent = p2<br />
	&emsp;else:<br />
	&emsp;&emsp;p2.parent = p1<br />
	&emsp;&emsp;p1.rank++<br />
	<br />
	<br />
	function pathCompress(v): // find<br />
	&emsp;if v != v.parent:<br />
	&emsp;&emsp;v.parent = pathCompress(v.parent)<br />
	&emsp;return v.parent<br />
  </div>

<hr>

  <h2> Sorting Algorithms </h2>
  <p class="subh2">Sort a list</p>

  <table>
  <tr><th>Algorithm</th><th>Time</th><th>Notes</th></tr>
  <tr><td>Selection sort</td><td>O(n<sup>2</sup>)</td><td>in place<br>slow (good for small inputs)</td></tr>
  <tr><td>Insertion sort</td><td>O(n<sup>2</sup>)</td><td>in place<br>slow (good for small inputs)</td></tr>
  <tr><td>Merge sort</td><td>O(n log n)</td><td>fast (good for large inputs)</td></tr>
  <tr><td>Quick sort</td><td>O(n log n)<br>expected</td><td>randomized<br>fastest (good for large inputs)</td></tr>
  <tr><td>Radix sort</td><td>O(nd)</td><td>d is number of digits in largest number<br>basically linear when d is small</td></tr>
  </table>
  <p> Mnemonic: SQuIRM (n<sup>2</sup>, n log n, n<sup>2</sup>,nd, n log n)

  <h3>Merge Sort</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">
	
  </div>

  <h3>Selection Sort</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">
	
  </div>

  <h3>Insertion Sort</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">
	
  </div>

  <h3>Reverse</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">
	
  </div>

  <h3>Quick Sort</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">
	
  </div>

  <h3>Radix Sort</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">
	
  </div>

  <h2> Selection &amp; Search Algorithms </h2>
  <p class="subh2">Algorithms to find things</p>

  <h3>Selection</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">

  </div>

  <h3>Median of Medians</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">

  </div>

  <h3>Binary Search</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">

  </div>

  <h3>Angular Graham Scan</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> for a convex hull
  </p>

  <h2> Tree Traversals </h2>
  <p class="subh2">Search through a tree</p>

  <h3>Breadth-First Traversal</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">

  </div>

  <h3>Depth-First Traversal</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">

  </div>

  <h3>Recursive Breadth-First Traversal</h3>
  <p class="subh3">
	<span class="subh3_bold">Runtime:</span> O(n log n) <br />
	<span class="subh3_bold">Notes:</span> not in-place
  </p>
  <div class="code_snippet">

  </div>

  <h2> Graphs v Trees </h2>
  <p> A graph G is a tree if and only if it satisfies any of the following 5 conditions: <br />
  <ul>
  	<li>G has V-1 edges and no cycles </li>
	<li>G has V-1 edges and is connected</li>
	<li>G is connected, but removing any edge disconnects it</li>
	<li>G is acyclic, but adding any edges creates a cycle</li>
	<li>Exactly one simple path connects each pair of vertices in G</li>
  </ul>


  <h2> Abstract Data Types (ADTs) </h2>
  <table>
  	<tr><th>ADT</th><th>Structure</th><th>Main Methods</th><th>Properties</th></tr> 
  	<tr>
  		<td> PQ </td>
  		<td> Heap </td>
  		<td> insert(key,element)  O(log n) <br />
  			 removeMin()          O(log n) <br />
  			 <br />
  			 upheap()             O(log n) <br />
  			 downheap()           O(log n) <br />
  		</td>
  		<td>
  			- Binary: each node has <= 2 children<br />
  			- Key/priority at each node<br />
  			- Left-complete<br />
  			- Preserves heap order: min or max<br />
  			&emsp;- min: n.key >= n.parent.key<br />
  			&emsp;- max: n.key <= n.parent.key<br />
  		</td>
  	</tr>
  	<tr>
  		<td> Treap </td>
  		<td> BST + Heap </td>
  		<td> insert(key,element)  O(log n) <br />
  			 removeMin()          O(log n) <br />
  			 <br />
  			 upheap()             O(log n) <br />
  			 downheap()           O(log n) <br />
  		</td>
  		<td>
  			- A non-empty tree <em>T</em> with a key and a priority at each node<br />
  			- <em>T</em> has only one node, or<br />
  			- <em>T</em> has a root <em>R</em> whose left and right subtrees are both treaps <br />
  			- Node's priority preserves heap order<br />
  			- Node's key preserves BST ordering<br />
  		</td>
  	</tr>
  	<tr>
  		<td> Tree </td>
  		<td>  </td>
  		<td><u>tree methods:</u><br />
  			size() <br />
  			isEmpty() <br />
  			root() <br />
  			<br />
  			<u>node methods:</u><br />
  			parent()<br />
  			children()<br />
  			isInternal()<br />
  			isExternal()<br />
  			isRoot()<br />
  			<br />
  			<u>binary tree node methods:</u><br />
  			hasLeft()<br />
  			hasRight()<br />
  			left()<br />
  			right()<br />
  		</td>
  		<td>
  			# nodes = n <br />
  			# edges = n - 1<br />
  			height = h <br />
  			<br />
  			<u>perfect binary tree:</u> <br />
  			height = h = log(n+1)-1 <sub>(base 2)</sub> <br />
  			# nodes = n = 2<sup>(h+1)</sup>-1<br /> = 2L-1 <br />
  			# leaves = L = 2<sup>h</sup><br />
  		</td>
  	</tr>
  	<tr><td> Trie </td> <td> Prefix Tree </td><td> insert() <br /> find() </td><td> each node has a dictionary of children </td></tr>
  </table>

  <h2> Algorithms </h2>
  <table>
  	<tr><th>Problem</th><th>Algorithm</th><th>Runtime</th><th>Data Structure</th></tr> 
  	<tr> <td>Sorting</td> <td>Insertion sort</td> <td>n<sup>2</sup></td> <td></td> </tr>
  	<tr> <td></td> <td>Selection sort</td> <td>worst case: n<sup>2</sup><br>expected: n</td> <td></td> </tr>
  	<tr> <td></td> <td>Merge sort</td> <td>n log n</td> <td></td> </tr>
  	<tr> <td></td> <td>Quick sort</td> <td>n log n</td> <td></td> </tr>
  	<tr> <td></td> <td>Radix sort</td> <td>dn</td> <td></td> </tr>
  	<tr> <td>Tree Traversals</td> <td>Breadth first</td> <td></td> <td>Queue</td> </tr>
  	<tr> <td></td> <td>Depth first</td> <td></td> <td>Stack</td> </tr>
  	<tr> <td></td> <td>Pre-order</td> <td></td> <td></td> </tr>
  	<tr> <td></td> <td>In-order</td> <td></td> <td></td> </tr>
  	<tr> <td></td> <td>Post-order</td> <td></td> <td></td> </tr>
  	<tr> <td></td> <td>Euler tour</td> <td>Left side: pre-order<br>Bottom: in-order<br>Right side: post-order</td> <td></td> </tr>
  	<tr> <td>Graph stuff</td> <td>BFT</td> <td>V+E</td> <td>Queue</td> </tr>
  	<tr> <td></td> <td>DFT</td> <td>V+E</td> <td>Stack</td> </tr>
  	<tr> <td></td> <td>Top Sort</td> <td>V+E</td> <td>Stack, Queue, etc.</td> </tr>
  	<tr> <td>Shortest Paths</td> <td>Dijkstra</td> <td>|V|<sup>2</sup><br><br>(|V|+|E|)* log|V|</td> <td>Array/Linked list <br><br>PQ/Binary Heap, etc.</td> </tr>
  	<tr> <td></td> <td>A*</td> <td>(V+E)log(V)</td> <td>PQ/Binary Heap, etc.</td> </tr>
  	<tr> <td></td> <td>Bellman-Ford</td> <td>VE</td> <td></td> </tr>
  	<tr> <td>MSTs</td> <td>Prim-Jarnik</td> <td>(V+E)logV</td> <td>PQ</td> </tr>
  	<tr> <td></td> <td>Kruskals<br>(plus union find)</td> <td>ElogE</td> <td><PQ/td> </tr>
  </table>


  </body>
</html>